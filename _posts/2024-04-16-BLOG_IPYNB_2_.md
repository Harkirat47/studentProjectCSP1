---
toc: True
comments: True
layout: post
title: Data Structures Writeup
description: Blog for CSP week 29
courses: {'csp': {'week': 29}}
type: hacks
---

# SQLite Database Table Creation:
Using VSCode and SQLite3 Editor, create a table in your SQLite database to store your collection data.
Define the columns in your table to represent the attributes of the collection items.
You might create a table named collections with columns like id, name, description, etc.

# Collections

# _________________________________________________________________________________________________________

## This is the Database of Images genorated by the model 
<img src="../../../images/IDB.png" alt="image13" style="border: 2px solid black; width: 1000px;">

From VSCode model, show your unique code that was created to initialize table and create test data.
See Code Below
Code initializes three users, two default ones as requested by teacher, and an admin account for personal use.


```python
def initEasyImages():
    with app.app_context():
        db.create_all()  # Create all tables if they don't exist
        # Provide paths and metadata for images
        images_data = [
            {"path": "link.jpg", "_xCoord": 250, "_yCoord": 250, "_difficulty": 0},
            {"path": "link.png", "_xCoord": 250, "_yCoord": 250, "_difficulty": 0}
        ]
        # Create image instances based on the provided data
        images = [Images(**data) for data in images_data]
        # Add images to the database
        for image in images:
            try:
                image.create()
                print("Successfully added entry")
            except:
                db.session.remove()
                print("Error adding image: ", image.imagePath)

```

## This is the code for the model with a function called initEasyImage that adds 2 images as Meta data as seen in the picture above.


```python
# Import necessary modules
from sqlalchemy import Column, Integer, String, Text, LargeBinary
from sqlalchemy.exc import IntegrityError
from pathlib import Path
from __init__ import app, db  # Import Flask app and SQLAlchemy database instance

# Define the Images table in the database
class Images(db.Model):
    __tablename__ = "images"
    id = db.Column(db.Integer, primary_key=True)
    _xCoord = Column(Integer, nullable=False, default=250)  # Default x-coordinate
    _yCoord = Column(Integer, nullable=False, default=250)  # Default y-coordinate
    _difficulty = Column(Integer, nullable=False, default=0)  # Default difficulty level
    imageData = db.Column(db.Text, nullable=True)
    imagePath = db.Column(db.Text, nullable=True)

    # Constructor to initialize an image object
    def __init__(self, imagePath, imageData=None): 
        self.imagePath = imagePath
        self.imageData = imageData

    # Method to represent the image object as a string
    def __repr__(self):
        return f"<image(id='{self.id}', imagePath='{self.imagePath}')>"

    # Method to convert image object to a dictionary
    def to_dict(self):
        return {"id": self.id, "imagePath": self.imagePath}

    # Method to add an image to the database
    def create(self):
        try:
            db.session.add(self)
            db.session.commit()
            return self
        except IntegrityError:
            db.session.remove()
            return None

    # Method to read the details of an image
    def read(self):
        return {
            "path": self.imagePath
        }

    # Method to update the details of an image
    def update(self, path=""):
        if path:
            self.imagePath = path
        db.session.commit()
        return self

    # Method to delete an image from the database
    def delete(self):
        db.session.delete(self)
        db.session.commit()
        return None

# Function to initialize images in the database
def initEasyImages():
    with app.app_context():
        db.create_all()  # Create all tables if they don't exist
        # Provide paths and metadata for images
        images_data = [
            {"path": "https://t3.ftcdn.net/jpg/03/95/29/32/360_F_395293226_A4boRgABAbfXmAmmynQHcjjIIB3MjDCj.jpg", 
             "_xCoord": 250, "_yCoord": 250, "_difficulty": 0},
            {"path": "https://purepng.com/public/uploads/large/purepng.com-super-mariomariosuper-mariovideo-
             gamefictional-characternintendoshigeru-miyamotomario-franchise-17015286383789a9am.png", "_xCoord": 250, "_yCoord": 250, "_difficulty": 0}
        ]
        # Create image instances based on the provided data
        images = [Images(**data) for data in images_data]
        # Add images to the database
        for image in images:
            try:
                image.create()
                print("Successfully added entry")
            except:
                db.session.remove()
                print("Error adding image: ", image.imagePath)

# Call the function to initialize images
initEasyImages()

```

# Lists and Dictionaries
Blog Python API code and use of List and Dictionaries.

In VSCode using Debugger, show a list as extracted from database as Python objects.
GET request is sent to backend to search for all public designs. Backend fetches all public designs into a list in python debugger called design_return (red line). List contains all designs as python objects (red line).



# API + Json

Blog Python API code and use of Postman to request and respond with JSON.

In VSCode, show Python API code definition for request and response using GET, POST, UPDATE methods. Discuss algorithmic condition used to direct request to appropriate Python method based on request method.
Within the code shown above, the API contains several CRUDs, such as a CRUD for modifying users and one for modifying Designs.
A resource is then added to the API under the appropriate link.
When a request is sent to the link, the appropriate function is called according to the type of request send.


```python
# Add resources outside the class definition
images_api.add_resource(ImagesAPI, '/')
images_api.add_resource(PostImagesAPI, '/upload')
```

In VSCode, show algorithmic conditions used to validate data on a POST condition.
Algorithmic conditions ensure that inputted data is valid. The following two conditions are part of the user creation code. They ensure that the password is secure by ensuring that it is longer than a certain length, and ensure that a Name and password exists.


```python
# Validate name
name = body.get('name')
if name is None or len(name) < 2:
    return {'message': 'Name is missing or is less than 2 characters'}, 400

# Validate uid
uid = body.get('uid')
if uid is None or len(uid) < 2:
    return {'message': 'User ID is missing or is less than 2 characters'}, 400
```

In Postman, show URL request and Body requirements for GET, POST, and UPDATE methods.
In Postman, show the JSON response data for 200 success conditions on GET, POST, and UPDATE methods.

## Post
<img src="../../../images/post.png" alt="image13" style="border: 2px solid black; width: 1000px;">

## PUT
<img src="../../../images/put.png" alt="image13" style="border: 2px solid black; width: 1000px;">

## GET
<img src="../../../images/get.png" alt="image13" style="border: 2px solid black; width: 1000px;">

## 404
<img src="../../../images/posterror.png" alt="image13" style="border: 2px solid black; width: 1000px;">


# frontend

## GET


```python
<img src="../../../images/12.png" alt="image12" style="border: 2px solid black; width: 1000px;">
```


```python
// Update the apiUrl to the correct endpoint in your backend server
const apiUrl = 'http://127.0.0.1:8086/api/images/'; // Update this URL

function downloadImage(imageUrl) {
  // Create a temporary anchor element
  var a = document.createElement('a');
  a.href = imageUrl;
  a.download = 'image.jpg';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
}

// Get token from cookies
const token = getCookies()['token'];

if (token) {
  fetch(apiUrl, {
    headers: {
      'Authorization': `Bearer ${token}`
    }
  })
  .then(response => {
    if (response.ok) {
      return response.json();
    } else {
      throw new Error('Token validation failed');
    }
  })
  .then(data => {
    const galleryContainer = $('#gallery_container');
    const imagesPerPage = 4; // Change this value to the desired number of images per page

    // Calculate the total number of pages
    const totalPages = Math.ceil(data.length / imagesPerPage);

    data.forEach((item, index) => {
      if (index % imagesPerPage === 0) {
        // Create a new page when needed
        const pageNum = index / imagesPerPage + 1;
        const pageLink = $(`<a href="#" data-page="${pageNum}">${pageNum}</a>`);
        pageLink.appendTo('#pagination_container');
      }

      var card = $('<div class="card"></div>'); // Create a card container
      var image = $('<img class="img">'); // Create an image element

      image.attr("src", "data:image/jpeg;base64," + item.imageData); // Set image source
      image.appendTo(card); // Append image to card

      // Adding click event listener to each image for enlarging
      image.on('click', function() {
        $('#lightbox_img').attr('src', this.src);
        $('#lightbox').fadeIn();
        $('.overlay').fadeIn();
        $('.download-button').fadeIn(); // Show download button
      });

      // Adding click event listener to download button
      $('.download-button').on('click', function() {
        downloadImage($('#lightbox_img').attr('src')); // Call downloadImage function with image source
      });

      card.appendTo(galleryContainer); // Append card to gallery container
    });

    // Add event listener for pagination
    $('#pagination_container a').on('click', function(e) {
      e.preventDefault();
      const pageNum = parseInt($(this).attr('data-page'));
      showPage(pageNum);
    });

    // Function to display the images for the selected page
    function showPage(pageNum) {
      galleryContainer.children('.card').hide(); // Hide all images
      galleryContainer.children(`.card:nth-child(n+${(pageNum - 1) * imagesPerPage + 1}):nth-child(-n+${pageNum * imagesPerPage})`).show(); // Show images for the selected page
    }

    // Initially show the first page
    showPage(1);
  })
  .catch(error => console.error('Error fetching images:', error));
} else {
  // Handle case when token is not available
  console.log('Token not available. Please login.');
}

// Function to get cookies
function getCookies() {
  var cookies = {};
  document.cookie.split(';').forEach(function(cookie) {
    var parts = cookie.split('=');
    cookies[parts.shift().trim()] = decodeURI(parts.join('='));
  });
  return cookies;
}

// Close lightbox when close button is clicked
$('#closeLightbox').on('click', function() {
  $('#lightbox').fadeOut();
  $('.overlay').fadeOut();
  $('.download-button').fadeOut(); // Hide download button
});
```


 This JavaScript code retrieves a JWT token from cookies and uses it to authenticate a GET request to a backend server's endpoint (apiUrl) to fetch image data. Upon successful authentication, it processes the received JSON data to dynamically generate a gallery of images, displaying a specified number of images per page with pagination. Each image can be clicked to enlarge it in a lightbox, and there's an option to download the enlarged image. The pagination functionality allows users to navigate through multiple pages of images. Additionally, it includes error handling to manage cases where token validation fails or the fetch request encounters an error, and it provides a function to extract cookies and another to close the lightbox when a close button is clicked.

## Post 

<img src="../../../images/13.png" alt="image12" style="border: 2px solid black; width: 1000px;">


```python
function handleFiles(files) {
    // const myHeaders = new Headers();
    // myHeaders.append("Content-Type", "application/json");

    for (let i = 0; i < files.length; i++) {
      const file = files[i];
      if (file.type.match('image.*')) {
        const reader = new FileReader();
        reader.onload = function (event) {
          const fileName = file.name;
          const base64String = event.target.result.split(',')[1];
          console.log(base64String); // Log base64 representation
          
          // Send base64String to server
          fetch('http://localhost:8086/api/images/upload', {
            method: 'POST',
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify({ 
              base64_string : base64String,
              name: fileName, 
            })
          })
          .then(response => {
            if (response.ok) {
              return response.json();
            } else {
              throw new Error('Upload failed');
            }
          })
          .then(data => {
            // Handle successful upload
            console.log(data);
            alert('Image uploaded successfully');
          })
          .catch(error => {
            // Handle errors
            console.error(error);
            alert('Upload failed. Please try again.');
          });
        };
        reader.readAsDataURL(file);
      } else {
        alert('Please select an image file.');
      }
    }
  }
```

 This JavaScript function handleFiles is designed to handle files selected by the user, particularly image files. When files are passed to this function, it iterates over each file using a for loop. For each file, it checks if the file type matches that of an image using the file.type.match('image.*') condition. If it's an image file, it proceeds to read the contents of the file using a FileReader. Upon successful reading of the file, it extracts the file name and converts the image data into a base64-encoded string. This base64 string, along with the file name, is then sent to the server via a POST request to the specified endpoint (http://localhost:8086/api/images/upload). The request includes the base64 string and file name in JSON format in the request body. After the upload request is made, it handles the response: if the response is successful, it logs the response data and displays an alert indicating successful upload; if there's an error in the upload process, it logs the error and displays an alert indicating upload failure. This function provides a convenient way to upload images to the server asynchronously.
